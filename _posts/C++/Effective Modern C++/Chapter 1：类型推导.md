## 条款一：模板类型推导

对于下面一段模板伪代码：

```c++
template<typename T>
void f(ParamType param);	// ParamType
```

`ParamType` 是模板形参类型，常带有修辞词(const)或引用声明。接下来将要谈论的几种情况：

- 值传递：`ParamType`为`T`
- 引用传递：
  - 左值引用：`ParamType`为`T&`或`T const&`
  - 万能引用：`ParamType`为`T&&`
- 指针传递：`ParamType`为`T*`

### 类型推导规则

1. 无论是上述哪种情况，引用类型的实参都会被当作非引用类型处理

   这一点与普通函数调用类似，实参是否为引用类型不会影响到形参是否为引用

2. 值传递模板类型：实参的 const/volatile 会被去掉

   这一点与普通函数调用类似，值传递形参只是实参的副本，const/volatile 修饰对于值传递没有意义。

3. 引用传递模板类型：

   - a. 左值引用：遵循第1点，实参自带的引用类型会被忽略。
     - 1 const引用模板类型：实参的const会被忽略
     - 2 非const引用模板类型：实参的const会被模板类型保留，这一点与普通函数调用不同
   - b. 万能引用：会根据实参属于左值还是右值推导模板类型
     - 1 左值实参：模板类型会被解释为左值引用，剩下的推导过程与 3.a.1 相同
     - 2 右值实参：模板类型会被解释为右值引用。右值实参没有const而言了（因为是右值）

4. 指针模板类型：与左值引用推导规则类型

   1. 会取消掉实参的指针类型

### 示例



